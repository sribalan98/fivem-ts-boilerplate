{
  "version": 3,
  "sources": ["../getFiles.ts", "../readJson.ts", "../esbuild.ts", "../fxmanifest.ts"],
  "sourcesContent": ["import { readdir } from \"fs/promises\";\n\n/**\n * Returns a flattened array of all files located at the given paths.\n * @param paths - The directories to search for files.\n * @returns A promise that resolves to an array of file paths.\n */\nexport async function getFiles(...paths: string[]): Promise<string[]> {\n  const files = await Promise.all(\n    paths.map(async (dir) => {\n      try {\n        const dirents = await readdir(`${dir}/`, { withFileTypes: true });\n        const paths = await Promise.all(\n          dirents.map(async (dirent) => {\n            const path = `${dir}/${dirent.name}`;\n            return dirent.isDirectory() ? await getFiles(path) : path;\n          })\n        );\n\n        return paths.flat();\n      } catch (err) {\n        return [];\n      }\n    })\n  );\n\n  return files.flat();\n}\n", "import { readFile } from \"fs/promises\";\n\n/**\n * Reads and parses a JSON file at the given path.\n * @param path - The file path to read the JSON from.\n */\nexport async function readJson(path: string): Promise<any> {\n  return JSON.parse(await readFile(path, \"utf8\"));\n}\n", "import esbuild from \"esbuild\";\nimport { writeFile } from \"fs/promises\";\n\n/**\n * Creates a build process using esbuild.\n * @param watch - Whether to enable watch mode.\n * @param baseOptions - The base build options for esbuild.\n * @param environments - An array of environments with their names and esbuild options.\n * @param onBuild - A callback function that gets called after a successful build.\n */\nexport async function createBuilder(\n  watch: boolean,\n  baseOptions: esbuild.BuildOptions,\n  environments: { name: string; options: esbuild.BuildOptions }[],\n  onBuild: (files: Record<string, string>) => Promise<void>\n): Promise<void> {\n  const outfiles: Record<string, string> = {};\n  const plugins: esbuild.Plugin[] = [\n    {\n      name: \"build\",\n      setup(build) {\n        build.onEnd(async (result) => {\n          if (result.errors.length === 0) {\n            console.log(`Successfully built ${build.initialOptions.outfile}`);\n          }\n        });\n      },\n    },\n  ];\n\n  await Promise.all(\n    environments.map(async ({ name, options }) => {\n      outfiles[name] = `dist/${name}.js`;\n      options = {\n        bundle: true,\n        entryPoints: [`./src/${name}/index.ts`],\n        outfile: outfiles[name],\n        keepNames: true,\n        legalComments: \"inline\",\n        treeShaking: true,\n        ...baseOptions,\n        ...options,\n      };\n      options.plugins = [...(options.plugins || []), ...plugins];\n\n      const ctx = await esbuild.context(options).catch(() => process.exit(1));\n      return watch ? ctx.watch() : ctx.rebuild();\n    })\n  );\n\n  await writeFile(\".yarn.installed\", new Date().toISOString());\n  await onBuild(outfiles);\n\n  if (!watch) process.exit(0)\n}\n", "import { readJson } from \"./readJson.js\";\nimport { writeFile } from \"fs/promises\";\n\n/**\n * Reduces an array into a formatted string.\n * @param name - The name of the section.\n * @param files - The array of file names.\n * @returns The reduced string or an empty string if the array is empty.\n */\nfunction reduceArray(name: string, files?: string[]): string {\n  return files?.[0]\n    ? `\\n${name} {${files.reduce((acc, value) => {\n        return value ? `${acc}\\n\\t'${value}',` : acc;\n      }, \"\")}\\n}\\n`\n    : \"\";\n}\n\n/**\n * Reduces an object into a formatted string.\n * @param object - The object to reduce.\n * @returns The reduced string.\n */\nfunction reduceObject(object: Record<string, string>): string {\n  return Object.entries(object).reduce((acc, [key, value]) => {\n    return value ? `${acc}${key} '${value}'\\n` : acc;\n  }, \"\");\n}\n\n/**\n * Represents a Resource Manifest.\n */\ninterface FxResourceManifest {\n  client_scripts?: string[];\n  server_scripts?: string[];\n  shared_scripts?: string[];\n  files?: string[];\n  dependencies?: string[];\n  metadata?: Record<string, string>;\n}\n\n/**\n * Creates the `fxmanifest.lua` file based on the resource manifest.\n * @param resourceManifest - The resource manifest containing script and file information.\n * @returns The generated `fxmanifest.lua` content as a string.\n */\nexport async function createFxmanifest({\n  client_scripts,\n  server_scripts,\n  shared_scripts,\n  files,\n  dependencies,\n  metadata,\n}: FxResourceManifest): Promise<string> {\n  const pkg = await readJson(\"package.json\");\n  const fxmanifest = {\n    name: pkg.name,\n    author: pkg.author,\n    version: pkg.version,\n    license: pkg.license,\n    repository: pkg.repository?.url,\n    description: pkg.description,\n    fx_version: \"cerulean\",\n    game: \"gta5\",\n    ...(metadata || {}),\n  };\n\n  let output = reduceObject(fxmanifest);\n  output += reduceArray(\"files\", files);\n  output += reduceArray(\"client_scripts\", client_scripts);\n  output += reduceArray(\"server_scripts\", server_scripts);\n  output += reduceArray(\"shared_scripts\", shared_scripts);\n  output += reduceArray(\"dependencies\", dependencies);\n\n  await writeFile(\"fxmanifest.lua\", output);\n\n  return output;\n}\n"],
  "mappings": "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",
  "names": ["readdir", "getFiles", "paths", "dir", "dirents", "dirent", "path", "readFile", "readJson", "path", "esbuild", "writeFile", "createBuilder", "watch", "baseOptions", "environments", "onBuild", "outfiles", "plugins", "build", "result", "name", "options", "ctx", "writeFile", "reduceArray", "name", "files", "acc", "value", "reduceObject", "object", "key", "createFxmanifest", "client_scripts", "server_scripts", "shared_scripts", "dependencies", "metadata", "pkg", "readJson", "fxmanifest", "output"]
}
